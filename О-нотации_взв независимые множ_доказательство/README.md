Жадный метод предполагает, что на каждом шаге мы выбираем "лучший" локальный вариант, 
не учитывая глобальную структуру задачи. 
В случае задачи о взвешенном независимом множестве это означает, что мы можем выбрать вершину с максимальным весом, а затем исключить все её соседние вершины из дальнейшего рассмотрения.

Пример:

Рассмотрим граф с тремя вершинами: A, B и C, где:

- Вес A = 10
- Вес B = 1
- Вес C = 1
  
Граф соединяет A с B и C. Если мы применим жадный метод, то на первом шаге мы выберем A (вес 10) и исключим B и C, получив итоговый вес 10. Однако оптимальное независимое множество в этом случае — это {B, C}, с суммарным весом 2. Таким образом, жадный метод не дает оптимального решения.

Доказательство, что концепция "разделяй и властвуй" не подходит
Концепция "разделяй и властвуй" подразумевает, что задача может быть разбита на подзадачи, которые решаются независимо, а затем результаты объединяются для получения решения всей задачи. Однако в задаче о взвешенном независимом множестве мы не можем просто разбить граф на подграфы, поскольку выбор одной вершины может повлиять на возможность выбора вершин в других подграфах.

Пример:

Рассмотрим граф, состоящий из двух отдельных компонент:

Компонента 1: A (вес 5), B (вес 10)
Компонента 2: C (вес 1), D (вес 1)
Если мы применим "разделяй и властвуй", мы можем решить каждую компоненту отдельно:

В компоненте 1 оптимальное множество — {B} (вес 10).
В компоненте 2 оптимальное множество — {C, D} (вес 2).
Объединив результаты, мы получаем {B, C, D} с общим весом 12. Однако, если бы граф был соединён, например, через дополнительную вершину E (вес 20), то оптимальным решением могло бы быть {E} (вес 20), что показывает, что разделение на подзадачи не учитывает глобальную структуру графа и может привести к неверному решению.

Вывод
Таким образом, ни жадный метод, ни концепция "разделяй и властвуй" не подходят для решения задачи о взвешенном независимом множестве, так как оба подхода не учитывают сложные взаимосвязи между вершинами и могут приводить к неоптимальным решениям. Для решения этой задачи обычно используются более сложные методы, такие как динамическое программирование или алгоритмы на основе методов ветвей и границ.
