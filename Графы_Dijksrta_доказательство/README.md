#### Обозначения 
- G = (V, E): Граф, где:
  - V – множество вершин.
  - E – множество ребер.
- s: Начальная вершина (source).
- d[v]: Текущая оценка кратчайшего расстояния от s до вершины v. Изначально \( d[s] = 0 \), а для всех остальных вершин \( d[v] = \infty \).
- shortest_path[v]: Истинное кратчайшее расстояние от s до v. Это значение, которое мы хотим найти.
- S: Множество обработанных (settled) вершин. Это вершины, для которых мы уже знаем \( d[v] = shortest_path[v] \).
- V - S: Множество необработанных вершин.
- weight(u, v): Вес ребра между вершинами u и v.

## Последовательность доказательства

#### Цель:
Доказать, что после завершения алгоритма Дейкстры для каждой вершины v, достижимой из s, будет верно, что:
\[ d[v] = shortest_path[v] \]

### 1. Базовый случай (инициализация)

Изначально S = {s} (множество обработанных вершин содержит только стартовую вершину).
d[s] = 0, что верно, так как расстояние от стартовой вершины до самой себя равно 0.
d[v] = ∞ для всех v != s, что означает, что мы еще не знаем путь к другим вершинам.
Начальная вершина s помещается в множество обработанных S, как первая вершина, для которой d[s] = shortest_path[s].

### 2. Индуктивное предположение

После \( k \) итераций (где \( k \) - какое-то количество шагов алгоритма), мы предполагаем, что для всех вершин v в S (то есть, для всех обработанных вершин), верно, что:
\[ d[v] = shortest_path[v] \]
Иными словами, мы нашли истинные кратчайшие пути для всех вершин в множестве S.

### 3. Индуктивный шаг (последовательность доказательства)

Алгритм выбирает вершину U из множества необработанных вершин \( (V - S) \), такую, что \( d[U] \) минимально среди всех вершин в \( (V - S) \).

Теперь нам нужно доказать, что для выбранной вершины U верно, что:
\[ d[U] = shortest_path[U] \]
То есть, что текущая оценка расстояния до U является истинным кратчайшим расстоянием.

#### Доказательство от противного

Предположение: Допустим, что \( d[U] > shortest_path[U] \). То есть, пусть существует более короткий путь до U, чем тот, что алгоритм нашел на данный момент (т.е. \( d[U] \)).

Анализ более короткого пути:
Рассмотрим истинный кратчайший путь \( P \) от s до U. Так как U не входит в S, то на пути \( P \) существует вершина X, которая является последней вершиной в S (то есть, X находится в S, а все вершины после X на пути \( P \) находятся в \( (V - S) \)).

Таким образом, мы можем разделить путь \( P \) на две части:
1. \( s \to ... \to X \) (где все вершины находятся в S)
2. \( X \to ... \to U \) (где U и все промежуточные вершины не находятся в S).

#### Получается противоречие

Так как X находится в S, то, по нашему индуктивному предположению, \( d[X] = shortest_path[X] \) (мы уже нашли кратчайший путь до X).

Также мы помним, что алгоритм выбирает всегда вершину U из множества \( (V - S) \), у которой \( d[U] \) минимально. Следовательно, путь через X не может быть меньше пути до U в силу алгоритма выбора. Иными словами:
\[ d[X] + weight(X, U) \geq d[U] \]

Но так как мы предположили, что существует более короткий путь до U, это значит, что путь \( P \) должен быть короче, чем \( d[U] \). Но мы показали, что путь через X (который является частью пути \( P \)) не может быть короче, чем \( d[U] \). Это и есть противоречие.

Наше предположение, что \( d[U] > shortest_path[U] \), неверно.

#### Вывод 

Из этого следует, что:
\[ d[U] \leq shortest_path[U] \]
И так как алгоритм Дейкстры находит минимальный путь, то:
\[ d[U] \geq shortest_path[U] \]
Следовательно:
\[ d[U] = shortest_path[U] \]
Это означает, что мы действительно нашли кратчайший путь до вершины U.

Теперь, когда мы знаем, что \( d[U] = shortest_path[U] \), мы добавляем вершину U в множество обработанных вершин:
\[ S = S \cup \{U\} \]

Таким образом, на каждом шаге, когда мы добавляем новую вершину в S, ее оценка кратчайшего расстояния \( d[v] \) соответствует истинному кратчайшему расстоянию \( shortest_path[v] \).

Следовательно, когда алгоритм завершит работу (т.е. S будет содержать все достижимые вершины), для всех этих вершин будет верно, что:
\[ d[v] = shortest_path[v] \]
